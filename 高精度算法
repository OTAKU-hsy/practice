#include<bits/stdc++.h>
using namespace std;

bool compare(string m, string n) {
	int Lm = m.length();
	int Ln = n.length();
	if (Lm != Ln)
		return Lm > Ln;
	for (int i = 0; i < Lm; i++)
		if (m[i] != n[i])
			return m[i] > n[i];
	return 1;
}

string jiafa(string m, string n) {
	if (!compare(m, n))
		swap(m, n);
	int Lm = m.length();
	int Ln = n.length();
	int* a = new int[Lm + 1];
	int* b = new int[Ln + 1];
	int* ans = new int[Lm + 2]();
	for (int i = 0; i < Lm; i++)
		a[Lm - i] = m[i] - '0';
	for (int i = 0; i < Ln; i++)
		b[Ln - i] = n[i] - '0';
	for (int i = 1; i <= Ln; i++) {
		ans[i] += a[i] + b[i];
		ans[i + 1] += ans[i] / 10;
		ans[i] %= 10;
	}
	for (int i = Ln + 1; i <= Lm; i++) {
		ans[i] += a[i];
		ans[i + 1] += ans[i] / 10;
		ans[i] %= 10;
	}
	delete[]a;
	delete[]b;
	while (ans[Lm + 1] == 0 && Lm > 0)
		Lm--;
	string k;
	for (int i = Lm + 1; i > 0; i--)
		k += (char)(ans[i] + '0');
	delete[]ans;
	return k;
}

string jianfa(string m, string n) {
	string k;
	if (m == n)
		k += (char)'0';
	else {
		int flag = 0;
		if (!compare(m, n)) {
			flag = 1;
			swap(m, n);
		}
		int Lm = m.length();
		int Ln = n.length();
		int* a = new int[Lm + 2]();
		int* b = new int[Ln + 2]();
		int* ans = new int[Lm + 2]();
		for (int i = 0; i < Lm; i++)
			a[Lm - i] = m[i] - '0';
		for (int i = 0; i < Ln; i++)
			b[Ln - i] = n[i] - '0';
		for (int i = 1; i <= Ln; i++) {
			if (a[i] < b[i]) {
				a[i + 1]--;
				a[i] += 10;
			}
			ans[i] = a[i] - b[i];
		}
		for (int i = Ln + 1; i <= Lm; i++) {
			if (a[i] < 0) {
				a[i] += 10;
				a[i + 1]--;
			}
			ans[i] = a[i];
		}
		delete[]a;
		delete[]b;
		while (ans[Lm] == 0 && Lm > 0)
			Lm--;
		if (flag == 1)
			k += '-';
		for (int i = Lm; i > 0; i--)
			k += (char)(ans[i] + '0');
		delete[]ans;
	}
	return k;
}

string chengfa(string m, string n) {
	string k;
	if (m == "0" || n == "0")
		k += "0";
	else {
		int Lm = m.length();
		int Ln = n.length();
		int x = Lm + Ln;
		int* a = new int[Lm + 1]();
		int* b = new int[Ln + 1]();
		int* ans = new int[x + 2]();
		for (int i = 0; i < Lm; i++)
			a[Lm - i] = m[i] - '0';
		for (int i = 0; i < Ln; i++)
			b[Lm - i] = n[i] - '0';
		for (int i = 1; i <= Lm; i++) {
			for (int j = 1; j <= Ln; j++) {
				ans[i + j - 1] += a[i] * b[j];
				ans[i + j] += ans[i + j - 1] / 10;
				ans[i + j - 1] %= 10;
			}
		}
		delete[]a;
		delete[]b;
		while (ans[x] == 0 && x > 0)
			x--;
		for (int i = x; i > 0; i--)
			k += (char)(ans[i] + '0');
		delete[]ans;
	}
	return k; 
}

string chufa(string m, string n) {
	string k;
	return k;
}

int main() {
	string m, n;
	cin >> m >> n;
	cout << chengfa(m, n);
	return 0;
}



#include <bits/stdc++.h>
using namespace std;
//最大能接受1000位数
struct BigInt{
    int len;
    int sign;
    char data[1005];
};
int compare(struct BigInt bigint1, struct BigInt bigint2);
void print_bigint(struct BigInt bigint);
struct BigInt read_bigint();
struct BigInt add_bigint(struct BigInt bigint1, struct BigInt bigint2);
struct BigInt sub_bigint(struct BigInt bigint1, struct BigInt bigint2);

int main() {
    struct BigInt bigint1 = read_bigint();
    struct BigInt bigint2 = read_bigint();
    print_bigint(add_bigint(bigint1, bigint2));
    print_bigint(sub_bigint(bigint1, bigint2));
    return 0;
}

//判断bigint1的绝对值是否大于bigint2的绝对值，相同返回2
int compare(struct BigInt bigint1, struct BigInt bigint2) {
    if (bigint1.len != bigint2.len)
        return bigint1.len > bigint2.len;
    for (int i = 1; i <= bigint1.len; i++)
        if (bigint1.data[i] != bigint2.data[i])
            return bigint1.data[i] > bigint2.data[i];
    return 2;
}
//输入 需要输入n的(正负号以外的)长度 空格 数n
struct BigInt read_bigint() {
    struct BigInt bigint;
    cin >> bigint.len;
    string x;
    cin >> x;
    if (x[0] == '-') {
        bigint.sign = -1;
        for (int i = 1; i <= bigint.len; i++)
            bigint.data[i] = x[i];
    }
    else {
        bigint.sign = 1;
        for (int i = 1; i <= bigint.len; i++)
            bigint.data[i] = x[i - 1];
    }
    return bigint;
}
//输出，自动换行
void print_bigint(struct BigInt bigint) {
    if (!bigint.sign)
        cout << '-';
    for (int i = 1; i <= bigint.len; i++)
        cout << bigint.data[i];
    cout << '\n';
}
// 加法
struct BigInt add_bigint(struct BigInt bigint1, struct BigInt bigint2) {
    struct BigInt ret;
    if (bigint1.data[1] == '0' && bigint2.data[1] == '0') {
        ret.sign = 1;
        ret.len = 1;
        ret.data[1] = '0';
    }
    //特判0+0
    else{
        if (bigint1.sign != bigint2.sign) {
            bigint2.sign ^= 1;
            sub_bigint(bigint1, bigint2);
        }
        //符号不同，使用减法
        else {
            ret.sign = bigint1.sign;
            //确定答案符号
            if (!compare(bigint1, bigint2)) 
                swap(bigint1, bigint2);
            //使绝对值大的数为bigint1
            int* a = new int[bigint1.len + 1]();
            int* b = new int[bigint2.len + 1]();
            int* ans = new int[bigint1.len + 2]();
            for (int i = 1; i <= bigint1.len; i++)
                a[bigint1.len - i + 1] = bigint1.data[i] - '0';
            for (int i = 1; i <= bigint2.len; i++)
                b[bigint2.len - i + 1] = bigint2.data[i] - '0';
            for (int i = 1; i <= bigint2.len; i++) {
                ans[i] += a[i] + b[i];
                ans[i + 1] += ans[i] / 10;
                ans[i] %= 10;
            }
            for (int i = bigint2.len + 1; i <= bigint1.len; i++) {
                ans[i] += a[i];
                ans[i + 1] += ans[i] / 10;
                ans[i] %= 10;
            }
            delete[]a;
            delete[]b;
            int x = bigint1.len + 1;
            while (ans[x] == 0 && x > 0)
                x--;
            ret.len = x;
            //确定答案长度
            for (int i = x; i > 0; i--)
                ret.data[x - i + 1] = (char)(ans[i] + '0');
            delete[]ans;
        }
    }
    return ret;
}
// 减法
struct BigInt sub_bigint(struct BigInt bigint1, struct BigInt bigint2) {
    struct BigInt ret;
    if (bigint1.data[1] == '0' && bigint2.data[1] == '0') {
        ret.sign = 1;
        ret.len = 1;
        ret.data[1] = '0';
    }
    //特判0-0
    else {
        if (bigint1.sign != bigint2.sign) {
            bigint2.sign ^= 1;
            return add_bigint(bigint1, bigint2);
        }
        //若异号，可化为加法
        if (compare(bigint1, bigint2) == 2) {
            ret.sign = 1;
            ret.len = 1;
            ret.data[1] = '0';
        }
        //特判结果0
        else {
            if (compare(bigint1, bigint2))
                ret.sign = bigint1.sign;
            else {
                ret.sign = bigint1.sign ^ 1;
                swap(bigint1, bigint2);
            }
            //确定答案的符号
            //使绝对值大的为bigint1，则去掉符号后结果为正
                int* a = new int[bigint1.len + 1]();
                int* b = new int[bigint2.len + 1]();
                int* ans = new int[bigint1.len + 1]();
                for (int i = 1; i <= bigint1.len; i++)
                    a[bigint1.len - i + 1] = bigint1.data[i] - '0';
                for (int i = 1; i <= bigint2.len; i++)
                    b[bigint2.len - i + 1] = bigint2.data[i] - '0';
                for (int i = 1; i <= bigint2.len; i++) {
                    if (a[i] < b[i]) {
                        a[i + 1]--;
                        a[i] += 10;
                    }
                    ans[i] = a[i] - b[i];
                }
                for (int i = bigint2.len + 1; i <= bigint1.len; i++) {
                    if (a[i] < 0) {
                        a[i] += 10;
                        a[i + 1]--;
                    }
                    ans[i] += a[i];
                }
                delete[]a;
                delete[]b;
                int x = bigint1.len;
                while (ans[x] == 0 && x > 0)
                    x--;
                ret.len = x;
                for (int i = x; i > 0; i--)
                    ret.data[x - i + 1] = (char)(ans[i] + '0');
                delete[]ans;
        }
    }
    return ret;
}
